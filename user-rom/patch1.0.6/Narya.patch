--- Arduino/libraries/FabGL/src/emudevs/Z80.h	2022-03-19 07:11:10.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/emudevs/Z80.h	2022-05-15 14:27:44.192998756 +0900
@@ -44,8 +44,9 @@
  * accepted at the instruction right after a DI or EI on an actual processor.
  */
 
-/*
+
  #define Z80_CATCH_HALT
+/*
  #define Z80_CATCH_DI
  #define Z80_CATCH_EI
  #define Z80_CATCH_RETI
@@ -271,12 +272,15 @@
   uint16_t getPC()                            { return state.pc; }
   void setPC(uint16_t value)                  { state.pc = value; }
 
+  int getStatus()                             { return state.status; }
+  int getIM()                                 { return state.im; }
+  int getIFF1()                               { return state.iff1; }
+  int getIFF2()                               { return state.iff2; }
 
 private:
 
   int intemulate(int opcode, int elapsed_cycles);
 
-
   Z80_STATE         state;
 
   // callbacks
--- Arduino/libraries/FabGL/src/emudevs/Z80.cpp	2022-03-19 07:11:10.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/emudevs/Z80.cpp	2022-05-15 14:27:38.060833173 +0900
@@ -2838,7 +2838,7 @@
 
   #ifdef Z80_CATCH_HALT
 
-        state.status = Z80_STATUS_FLAG_HALT;
+        state.status = Z80_STATUS_HALT;
 
   #endif
 
@@ -2852,7 +2852,7 @@
 
   #ifdef Z80_CATCH_DI
 
-        state.status = Z80_STATUS_FLAG_DI;
+        state.status = Z80_STATUS_DI;
 
   #endif
 
@@ -2866,7 +2866,7 @@
 
   #ifdef Z80_CATCH_EI
 
-        state.status = Z80_STATUS_FLAG_EI;
+        state.status = Z80_STATUS_EI;
 
   #endif
 
@@ -3797,16 +3797,16 @@
   #if defined(Z80_CATCH_RETI) && defined(Z80_CATCH_RETN)
 
         state.status = opcode == OPCODE_RETI
-        ? Z80_STATUS_FLAG_RETI
-        : Z80_STATUS_FLAG_RETN;
+        ? Z80_STATUS_RETI
+        : Z80_STATUS_RETN;
 
   #elif defined(Z80_CATCH_RETI)
 
-        state.status = Z80_STATUS_FLAG_RETI;
+        state.status = Z80_STATUS_RETI;
 
   #elif defined(Z80_CATCH_RETN)
 
-        state.status = Z80_STATUS_FLAG_RETN;
+        state.status = Z80_STATUS_RETN;
 
   #endif
 
--- Arduino/libraries/FabGL/src/devdrivers/kbdlayouts.h	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/devdrivers/kbdlayouts.h	2022-05-15 14:27:21.964349475 +0900
@@ -114,10 +114,13 @@
 /** @brief Belgian keyboard layout */
 extern const KeyboardLayout BelgianLayout;
 
+/** @brief Japanese keyboard layout */
+extern const KeyboardLayout JapaneseLayout;
+
 
 struct SupportedLayouts {
 
-  static constexpr int LAYOUTSCOUNT = 7;
+  static constexpr int LAYOUTSCOUNT = 8;
 
   static int count()               { return LAYOUTSCOUNT; }
 
@@ -130,6 +133,7 @@
         SpanishLayout.desc,
         FrenchLayout.desc,
         BelgianLayout.desc,
+        JapaneseLayout.desc,
     };
     return NAMES;
   }
@@ -143,6 +147,7 @@
         SpanishLayout.name,
         FrenchLayout.name,
         BelgianLayout.name,
+        JapaneseLayout.name,
     };
     return SNAMES;
   }
@@ -156,6 +161,7 @@
         &SpanishLayout,
         &FrenchLayout,
         &BelgianLayout,
+        &JapaneseLayout,
     };
     return LAYOUTS;
   }
--- Arduino/libraries/FabGL/src/devdrivers/kbdlayouts.cpp	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/devdrivers/kbdlayouts.cpp	2022-05-15 14:27:16.280161365 +0900
@@ -936,6 +936,67 @@
 
 
 
+/**************************************************************************************/
+/* Japanese LAYOUT                                                                    */
+/**************************************************************************************/
+const KeyboardLayout JapaneseLayout {
+  // name
+  "JP",
+
+  // desc
+  "Japanese",
+
+  // inherited layout
+  &USLayout,
+
+  // single byte scancodes
+  {
+    { 0x0E, VK_HANKAKU_ZENKAKU_KANJI },
+    { 0x55, VK_CARET },
+    { 0x54, VK_AT },
+    { 0x5B, VK_LEFTBRACKET },
+    { 0x5D, VK_RIGHTBRACKET },
+    { 0x52, VK_COLON },
+    { 0x6A, VK_YEN },
+    { 0x51, VK_BACKSLASH },
+    { 0x67, VK_MUHENKAN },
+    { 0x64, VK_HENKAN },
+    { 0x13, VK_KATAKANA_HIRAGANA_ROMAJI },
+  },
+
+  // extended scancodes (0xE0..)
+  {
+  },
+
+  // virtual keys generated by other virtual keys combinations
+  //  in_key, { CTRL, LALT, RALT, SHIFT }, out_key
+  {
+    { VK_2,            { 0, 0, 0, 1 }, VK_QUOTEDBL },     // SHIFT "2" = """
+    { VK_6,            { 0, 0, 0, 1 }, VK_AMPERSAND },    // SHIFT "6" = "&"
+    { VK_7,            { 0, 0, 0, 1 }, VK_QUOTE },        // SHIFT "7" = "'"
+    { VK_8,            { 0, 0, 0, 1 }, VK_LEFTPAREN },    // SHIFT "8" = "("
+    { VK_9,            { 0, 0, 0, 1 }, VK_RIGHTPAREN },   // SHIFT "9" = ")"
+    { VK_0,            { 0, 0, 0, 1 }, VK_SHIFT_0 },      // SHIFT "0" = ""
+    { VK_MINUS,        { 0, 0, 0, 1 }, VK_EQUALS },       // SHIFT "-" = "="
+    { VK_CARET,        { 0, 0, 0, 1 }, VK_TILDE },        // SHIFT "^" = "~"
+    { VK_YEN,          { 0, 0, 0, 1 }, VK_VERTICALBAR },  // SHIFT "￥" = "|"
+    { VK_AT,           { 0, 0, 0, 1 }, VK_GRAVEACCENT },  // SHIFT "@" = "`"
+    { VK_SEMICOLON,    { 0, 0, 0, 1 }, VK_PLUS },         // SHIFT ";" = "+"
+    { VK_COLON,        { 0, 0, 0, 1 }, VK_ASTERISK },     // SHIFT ":" = "*"
+    { VK_BACKSLASH,    { 0, 0, 0, 1 }, VK_UNDERSCORE },   // SHIFT "\" = "_"
+  },
+
+  // deadkeys
+  {
+  },
+
+  // deadkeys translation
+  {
+  },
+};
+
+
+
 
 
 
--- Arduino/libraries/FabGL/src/fabutils.h	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/fabutils.h.sd	2022-05-15 14:26:59.439549835 +0900
@@ -804,7 +804,8 @@
    *     // Mount SD Card
    *     FileBrowser::mountSDCard(false, "/sdcard");
    */
-  static bool mountSDCard(bool formatOnFail, char const * mountPath, size_t maxFiles = 4, int allocationUnitSize = 16 * 1024, int MISO = 16, int MOSI = 17, int CLK = 14, int CS = 13);
+  //static bool mountSDCard(bool formatOnFail, char const * mountPath, size_t maxFiles = 4, int allocationUnitSize = 16 * 1024, int MISO = 16, int MOSI = 17, int CLK = 14, int CS = 13);
+  static bool mountSDCard(bool formatOnFail, char const * mountPath, size_t maxFiles = 4, int allocationUnitSize = 16 * 1024, int MISO = 12, int MOSI = 13, int CLK = 14, int CS = 15);
 
   /**
    * @brief Remounts SDCard filesystem, using the same parameters
@@ -1310,6 +1311,15 @@
   VK_CURRENCY,        /**< Currency   : ¤ */
   VK_MU,              /**< Mu         : µ */
 
+  VK_HANKAKU_ZENKAKU_KANJI,
+                      /**< 半角/全角/漢字 */
+  VK_YEN,             /**< YEN: ￥ */
+  VK_MUHENKAN,        /**< 無変換 */
+  VK_HENKAN,          /**< 変換 */
+  VK_KATAKANA_HIRAGANA_ROMAJI,
+                      /**< カタカナ/ひらがな/ローマ字 */
+  VK_SHIFT_0,         /** SHIFT 0 */
+
   VK_ASCII,           /**< Specifies an ASCII code - used when virtual key is embedded in VirtualKeyItem structure and VirtualKeyItem.ASCII is valid */
   VK_LAST,            // marks the last virtual key
 
--- Arduino/libraries/FabGL/src/fabutils.cpp	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/fabutils.cpp	2022-05-15 14:26:43.698903010 +0900
@@ -1184,8 +1184,8 @@
       MOSI = 12;
       break;
     case ChipPackage::ESP32D0WDQ5:
-      MISO = 35;
-      MOSI = 12;
+      // MISO = 35;
+      // MOSI = 12;
       break;
     default:
       break;
--- Arduino/libraries/FabGL/src/inputbox.cpp	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/inputbox.cpp	2022-05-15 14:27:05.715787337 +0900
@@ -87,7 +87,8 @@
 
   // setup keyboard and mouse
   if (!PS2Controller::initialized())
-    PS2Controller::begin(PS2Preset::KeyboardPort0_MousePort1, KbdMode::GenerateVirtualKeys);
+    //PS2Controller::begin(PS2Preset::KeyboardPort0_MousePort1, KbdMode::GenerateVirtualKeys);
+    PS2Controller::begin(PS2Preset::KeyboardPort0, KbdMode::GenerateVirtualKeys);
   else
     PS2Controller::keyboard()->enableVirtualKeys(true, true);
 }
--- Arduino/libraries/FabGL/src/dispdrivers/vgabasecontroller.cpp	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/dispdrivers/vgabasecontroller.cpp	2022-05-15 14:27:29.500584836 +0900
@@ -113,7 +113,8 @@
 // initializer for default configuration
 void VGABaseController::begin()
 {
-  begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_15);
+  //begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_15);
+  begin(GPIO_NUM_22, GPIO_NUM_21, GPIO_NUM_19, GPIO_NUM_18, GPIO_NUM_5, GPIO_NUM_4, GPIO_NUM_23, GPIO_NUM_27);
 }
 
 
--- Arduino/libraries/FabGL/src/emudevs/i8042.cpp	2022-03-19 07:11:25.000000000 +0900
+++ Arduino/FabGL/n80FabGL/patch/src/emudevs/i8042.cpp	2022-05-15 14:27:49.813141636 +0900
@@ -94,7 +94,8 @@
 
   // keyboard configured on port 0, and optionally mouse on port 1
   if (!PS2Controller::initialized())
-    m_PS2Controller.begin(PS2Preset::KeyboardPort0_MousePort1, KbdMode::NoVirtualKeys);
+    //m_PS2Controller.begin(PS2Preset::KeyboardPort0_MousePort1, KbdMode::NoVirtualKeys);
+    m_PS2Controller.begin(PS2Preset::KeyboardPort0, KbdMode::NoVirtualKeys);
   else
     m_PS2Controller.keyboard()->enableVirtualKeys(false, false);
   m_keyboard = m_PS2Controller.keyboard();
@@ -196,7 +197,7 @@
   }
 
   // something to receive from mouse?
-  if ((m_STATUS & STATUS_OBF) == 0 && (m_mousePacketIdx > -1 || m_mouse->packetAvailable()) && (m_commandByte & CMDBYTE_DISABLE_MOUSE) == 0) {
+  if ((m_STATUS & STATUS_OBF) == 0 && (m_mousePacketIdx > -1 || (m_mouse && m_mouse->packetAvailable())) && (m_commandByte & CMDBYTE_DISABLE_MOUSE) == 0) {
     if (m_mousePacketIdx == -1)
       m_mouse->getNextPacket(&m_mousePacket);
     m_DBBOUT = m_mousePacket.data[++m_mousePacketIdx];
@@ -222,7 +223,10 @@
   if (m_STATUS & STATUS_IBF) {
     m_STATUS &= ~(STATUS_IBF | STATUS_PARITY_ERR);
     if (m_writeToMouse)
-      m_mouse->sendCommand(m_DBBIN);
+    {
+      if (m_mouse)
+        m_mouse->sendCommand(m_DBBIN);
+    }
     else
       m_keyboard->sendCommand(m_DBBIN);
     m_writeToMouse = false;
@@ -268,7 +272,10 @@
       break;
 
     case CTRLCMD_TEST_MOUSE_PORT:
-      m_DBBOUT = m_mouse->isMouseAvailable() ? 0x00 : 0x02;
+      if (m_mouse)
+        m_DBBOUT = m_mouse->isMouseAvailable() ? 0x00 : 0x02;
+      else
+        m_DBBOUT = 0x02;
       m_STATUS |= STATUS_OBF;
       break;
 
@@ -323,7 +330,7 @@
   }
 
   // disable mouse bit changed?
-  if ((newValue ^ m_commandByte) & CMDBYTE_DISABLE_MOUSE) {
+  if (m_mouse && (newValue ^ m_commandByte) & CMDBYTE_DISABLE_MOUSE) {
     if (newValue & CMDBYTE_DISABLE_MOUSE) {
       m_mouse->suspendPort();
     } else {
